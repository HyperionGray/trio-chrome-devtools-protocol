# DO NOT EDIT THIS FILE!
#
# This code is generated off of PyCDP modules. If you need to make
# changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
import typing

from ..context import get_connection_context, get_session_context

import cdp.network
from cdp.network import (
    AuthChallenge,
    AuthChallengeResponse,
    BlockedCookieWithReason,
    BlockedReason,
    BlockedSetCookieWithReason,
    CachedResource,
    CertificateTransparencyCompliance,
    ClientSecurityState,
    ConnectTiming,
    ConnectionType,
    ContentEncoding,
    Cookie,
    CookieBlockedReason,
    CookieParam,
    CookiePriority,
    CookieSameSite,
    CookieSourceScheme,
    CorsError,
    CorsErrorStatus,
    CrossOriginEmbedderPolicyStatus,
    CrossOriginEmbedderPolicyValue,
    CrossOriginOpenerPolicyStatus,
    CrossOriginOpenerPolicyValue,
    DataReceived,
    ErrorReason,
    EventSourceMessageReceived,
    Headers,
    IPAddressSpace,
    Initiator,
    InterceptionId,
    InterceptionStage,
    LoadNetworkResourceOptions,
    LoadNetworkResourcePageResult,
    LoaderId,
    LoadingFailed,
    LoadingFinished,
    MonotonicTime,
    PostDataEntry,
    PrivateNetworkRequestPolicy,
    ReportId,
    ReportStatus,
    ReportingApiEndpoint,
    ReportingApiEndpointsChangedForOrigin,
    ReportingApiReport,
    ReportingApiReportAdded,
    ReportingApiReportUpdated,
    Request,
    RequestId,
    RequestIntercepted,
    RequestPattern,
    RequestServedFromCache,
    RequestWillBeSent,
    RequestWillBeSentExtraInfo,
    ResourceChangedPriority,
    ResourcePriority,
    ResourceTiming,
    ResourceType,
    Response,
    ResponseReceived,
    ResponseReceivedExtraInfo,
    SecurityDetails,
    SecurityIsolationStatus,
    ServiceWorkerResponseSource,
    SetCookieBlockedReason,
    SignedCertificateTimestamp,
    SignedExchangeError,
    SignedExchangeErrorField,
    SignedExchangeHeader,
    SignedExchangeInfo,
    SignedExchangeReceived,
    SignedExchangeSignature,
    SubresourceWebBundleInnerResponseError,
    SubresourceWebBundleInnerResponseParsed,
    SubresourceWebBundleMetadataError,
    SubresourceWebBundleMetadataReceived,
    TimeSinceEpoch,
    TrustTokenOperationDone,
    TrustTokenOperationType,
    TrustTokenParams,
    WebSocketClosed,
    WebSocketCreated,
    WebSocketFrame,
    WebSocketFrameError,
    WebSocketFrameReceived,
    WebSocketFrameSent,
    WebSocketHandshakeResponseReceived,
    WebSocketRequest,
    WebSocketResponse,
    WebSocketWillSendHandshakeRequest,
    WebTransportClosed,
    WebTransportConnectionEstablished,
    WebTransportCreated
)


async def can_clear_browser_cache() -> bool:
    '''
Tells whether clearing browser cache is supported.

.. deprecated:: 1.3

:returns: True if browser cache can be cleared.

.. deprecated:: 1.3
'''
    session = get_session_context('network.can_clear_browser_cache')
    return await session.execute(cdp.network.can_clear_browser_cache())


async def can_clear_browser_cookies() -> bool:
    '''
Tells whether clearing browser cookies is supported.

.. deprecated:: 1.3

:returns: True if browser cookies can be cleared.

.. deprecated:: 1.3
'''
    session = get_session_context('network.can_clear_browser_cookies')
    return await session.execute(cdp.network.can_clear_browser_cookies())


async def can_emulate_network_conditions() -> bool:
    '''
Tells whether emulation of network conditions is supported.

.. deprecated:: 1.3

:returns: True if emulation of network conditions is supported.

.. deprecated:: 1.3
'''
    session = get_session_context('network.can_emulate_network_conditions')
    return await session.execute(cdp.network.can_emulate_network_conditions())


async def clear_accepted_encodings_override() -> None:
    '''
    Clears accepted encodings set by setAcceptedEncodings

    **EXPERIMENTAL**
    '''
    session = get_session_context('network.clear_accepted_encodings_override')
    return await session.execute(cdp.network.clear_accepted_encodings_override())


async def clear_browser_cache() -> None:
    '''
    Clears browser cache.
    '''
    session = get_session_context('network.clear_browser_cache')
    return await session.execute(cdp.network.clear_browser_cache())


async def clear_browser_cookies() -> None:
    '''
    Clears browser cookies.
    '''
    session = get_session_context('network.clear_browser_cookies')
    return await session.execute(cdp.network.clear_browser_cookies())


async def continue_intercepted_request(
        interception_id: InterceptionId,
        error_reason: typing.Optional[ErrorReason] = None,
        raw_response: typing.Optional[str] = None,
        url: typing.Optional[str] = None,
        method: typing.Optional[str] = None,
        post_data: typing.Optional[str] = None,
        headers: typing.Optional[Headers] = None,
        auth_challenge_response: typing.Optional[AuthChallengeResponse] = None
    ) -> None:
    '''
Response to Network.requestIntercepted which either modifies the request to continue with any
modifications, or blocks it, or completes it with the provided response bytes. If a network
fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
event will be sent with the same InterceptionId.
Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param interception_id:
:param error_reason: *(Optional)* If set this causes the request to fail with the given reason. Passing ```Aborted```` for requests marked with ````isNavigationRequest``` also cancels the navigation. Must not be set in response to an authChallenge.
:param raw_response: *(Optional)* If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)
:param url: *(Optional)* If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge.
:param method: *(Optional)* If set this allows the request method to be overridden. Must not be set in response to an authChallenge.
:param post_data: *(Optional)* If set this allows postData to be set. Must not be set in response to an authChallenge.
:param headers: *(Optional)* If set this allows the request headers to be changed. Must not be set in response to an authChallenge.
:param auth_challenge_response: *(Optional)* Response to a requestIntercepted with an authChallenge. Must not be set otherwise.

.. deprecated:: 1.3
'''
    session = get_session_context('network.continue_intercepted_request')
    return await session.execute(cdp.network.continue_intercepted_request(interception_id, error_reason, raw_response, url, method, post_data, headers, auth_challenge_response))


async def delete_cookies(
        name: str,
        url: typing.Optional[str] = None,
        domain: typing.Optional[str] = None,
        path: typing.Optional[str] = None
    ) -> None:
    '''
    Deletes browser cookies with matching name and url or domain/path pair.

    :param name: Name of the cookies to remove.
    :param url: *(Optional)* If specified, deletes all the cookies with the given name where domain and path match provided URL.
    :param domain: *(Optional)* If specified, deletes only cookies with the exact domain.
    :param path: *(Optional)* If specified, deletes only cookies with the exact path.
    '''
    session = get_session_context('network.delete_cookies')
    return await session.execute(cdp.network.delete_cookies(name, url, domain, path))


async def disable() -> None:
    '''
    Disables network tracking, prevents network events from being sent to the client.
    '''
    session = get_session_context('network.disable')
    return await session.execute(cdp.network.disable())


async def emulate_network_conditions(
        offline: bool,
        latency: float,
        download_throughput: float,
        upload_throughput: float,
        connection_type: typing.Optional[ConnectionType] = None
    ) -> None:
    '''
    Activates emulation of network conditions.

    :param offline: True to emulate internet disconnection.
    :param latency: Minimum latency from request sent to response headers received (ms).
    :param download_throughput: Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
    :param upload_throughput: Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
    :param connection_type: *(Optional)* Connection type if known.
    '''
    session = get_session_context('network.emulate_network_conditions')
    return await session.execute(cdp.network.emulate_network_conditions(offline, latency, download_throughput, upload_throughput, connection_type))


async def enable(
        max_total_buffer_size: typing.Optional[int] = None,
        max_resource_buffer_size: typing.Optional[int] = None,
        max_post_data_size: typing.Optional[int] = None
    ) -> None:
    '''
    Enables network tracking, network events will now be delivered to the client.

    :param max_total_buffer_size: **(EXPERIMENTAL)** *(Optional)* Buffer size in bytes to use when preserving network payloads (XHRs, etc).
    :param max_resource_buffer_size: **(EXPERIMENTAL)** *(Optional)* Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
    :param max_post_data_size: *(Optional)* Longest post body size (in bytes) that would be included in requestWillBeSent notification
    '''
    session = get_session_context('network.enable')
    return await session.execute(cdp.network.enable(max_total_buffer_size, max_resource_buffer_size, max_post_data_size))


async def enable_reporting_api(
        enable: bool
    ) -> None:
    '''
    Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
    Enabling triggers 'reportingApiReportAdded' for all existing reports.

    **EXPERIMENTAL**

    :param enable: Whether to enable or disable events for the Reporting API
    '''
    session = get_session_context('network.enable_reporting_api')
    return await session.execute(cdp.network.enable_reporting_api(enable))


async def get_all_cookies() -> typing.List[Cookie]:
    '''
    Returns all browser cookies. Depending on the backend support, will return detailed cookie
    information in the ``cookies`` field.

    :returns: Array of cookie objects.
    '''
    session = get_session_context('network.get_all_cookies')
    return await session.execute(cdp.network.get_all_cookies())


async def get_certificate(
        origin: str
    ) -> typing.List[str]:
    '''
    Returns the DER-encoded certificate.

    **EXPERIMENTAL**

    :param origin: Origin to get certificate for.
    :returns: 
    '''
    session = get_session_context('network.get_certificate')
    return await session.execute(cdp.network.get_certificate(origin))


async def get_cookies(
        urls: typing.Optional[typing.List[str]] = None
    ) -> typing.List[Cookie]:
    '''
    Returns all browser cookies for the current URL. Depending on the backend support, will return
    detailed cookie information in the ``cookies`` field.

    :param urls: *(Optional)* The list of URLs for which applicable cookies will be fetched. If not specified, it's assumed to be set to the list containing the URLs of the page and all of its subframes.
    :returns: Array of cookie objects.
    '''
    session = get_session_context('network.get_cookies')
    return await session.execute(cdp.network.get_cookies(urls))


async def get_request_post_data(
        request_id: RequestId
    ) -> str:
    '''
    Returns post data sent with the request. Returns an error when no data was sent with the request.

    :param request_id: Identifier of the network request to get content for.
    :returns: Request body string, omitting files from multipart requests
    '''
    session = get_session_context('network.get_request_post_data')
    return await session.execute(cdp.network.get_request_post_data(request_id))


async def get_response_body(
        request_id: RequestId
    ) -> typing.Tuple[str, bool]:
    '''
    Returns content served for the given request.

    :param request_id: Identifier of the network request to get content for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    '''
    session = get_session_context('network.get_response_body')
    return await session.execute(cdp.network.get_response_body(request_id))


async def get_response_body_for_interception(
        interception_id: InterceptionId
    ) -> typing.Tuple[str, bool]:
    '''
    Returns content served for the given currently intercepted request.

    **EXPERIMENTAL**

    :param interception_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    '''
    session = get_session_context('network.get_response_body_for_interception')
    return await session.execute(cdp.network.get_response_body_for_interception(interception_id))


async def get_security_isolation_status(
        frame_id: typing.Optional[cdp.page.FrameId] = None
    ) -> SecurityIsolationStatus:
    '''
    Returns information about the COEP/COOP isolation status.

    **EXPERIMENTAL**

    :param frame_id: *(Optional)* If no frameId is provided, the status of the target is provided.
    :returns: 
    '''
    session = get_session_context('network.get_security_isolation_status')
    return await session.execute(cdp.network.get_security_isolation_status(frame_id))


async def load_network_resource(
        url: str,
        options: LoadNetworkResourceOptions,
        frame_id: typing.Optional[cdp.page.FrameId] = None
    ) -> LoadNetworkResourcePageResult:
    '''
    Fetches the resource and returns the content.

    **EXPERIMENTAL**

    :param frame_id: *(Optional)* Frame id to get the resource for. Mandatory for frame targets, and should be omitted for worker targets.
    :param url: URL of the resource to get content for.
    :param options: Options for the request.
    :returns: 
    '''
    session = get_session_context('network.load_network_resource')
    return await session.execute(cdp.network.load_network_resource(url, options, frame_id))


async def replay_xhr(
        request_id: RequestId
    ) -> None:
    '''
    This method sends a new XMLHttpRequest which is identical to the original one. The following
    parameters should be identical: method, url, async, request body, extra headers, withCredentials
    attribute, user, password.

    **EXPERIMENTAL**

    :param request_id: Identifier of XHR to replay.
    '''
    session = get_session_context('network.replay_xhr')
    return await session.execute(cdp.network.replay_xhr(request_id))


async def search_in_response_body(
        request_id: RequestId,
        query: str,
        case_sensitive: typing.Optional[bool] = None,
        is_regex: typing.Optional[bool] = None
    ) -> typing.List[cdp.debugger.SearchMatch]:
    '''
    Searches for given string in response content.

    **EXPERIMENTAL**

    :param request_id: Identifier of the network response to search.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    '''
    session = get_session_context('network.search_in_response_body')
    return await session.execute(cdp.network.search_in_response_body(request_id, query, case_sensitive, is_regex))


async def set_accepted_encodings(
        encodings: typing.List[ContentEncoding]
    ) -> None:
    '''
    Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.

    **EXPERIMENTAL**

    :param encodings: List of accepted content encodings.
    '''
    session = get_session_context('network.set_accepted_encodings')
    return await session.execute(cdp.network.set_accepted_encodings(encodings))


async def set_attach_debug_stack(
        enabled: bool
    ) -> None:
    '''
    Specifies whether to attach a page script stack id in requests

    **EXPERIMENTAL**

    :param enabled: Whether to attach a page script stack for debugging purpose.
    '''
    session = get_session_context('network.set_attach_debug_stack')
    return await session.execute(cdp.network.set_attach_debug_stack(enabled))


async def set_blocked_ur_ls(
        urls: typing.List[str]
    ) -> None:
    '''
    Blocks URLs from loading.

    **EXPERIMENTAL**

    :param urls: URL patterns to block. Wildcards ('*') are allowed.
    '''
    session = get_session_context('network.set_blocked_ur_ls')
    return await session.execute(cdp.network.set_blocked_ur_ls(urls))


async def set_bypass_service_worker(
        bypass: bool
    ) -> None:
    '''
    Toggles ignoring of service worker for each request.

    **EXPERIMENTAL**

    :param bypass: Bypass service worker and load from network.
    '''
    session = get_session_context('network.set_bypass_service_worker')
    return await session.execute(cdp.network.set_bypass_service_worker(bypass))


async def set_cache_disabled(
        cache_disabled: bool
    ) -> None:
    '''
    Toggles ignoring cache for each request. If ``true``, cache will not be used.

    :param cache_disabled: Cache disabled state.
    '''
    session = get_session_context('network.set_cache_disabled')
    return await session.execute(cdp.network.set_cache_disabled(cache_disabled))


async def set_cookie(
        name: str,
        value: str,
        url: typing.Optional[str] = None,
        domain: typing.Optional[str] = None,
        path: typing.Optional[str] = None,
        secure: typing.Optional[bool] = None,
        http_only: typing.Optional[bool] = None,
        same_site: typing.Optional[CookieSameSite] = None,
        expires: typing.Optional[TimeSinceEpoch] = None,
        priority: typing.Optional[CookiePriority] = None,
        same_party: typing.Optional[bool] = None,
        source_scheme: typing.Optional[CookieSourceScheme] = None,
        source_port: typing.Optional[int] = None,
        partition_key: typing.Optional[str] = None
    ) -> bool:
    '''
    Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.

    :param name: Cookie name.
    :param value: Cookie value.
    :param url: *(Optional)* The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie.
    :param domain: *(Optional)* Cookie domain.
    :param path: *(Optional)* Cookie path.
    :param secure: *(Optional)* True if cookie is secure.
    :param http_only: *(Optional)* True if cookie is http-only.
    :param same_site: *(Optional)* Cookie SameSite type.
    :param expires: *(Optional)* Cookie expiration date, session cookie if not set
    :param priority: **(EXPERIMENTAL)** *(Optional)* Cookie Priority type.
    :param same_party: **(EXPERIMENTAL)** *(Optional)* True if cookie is SameParty.
    :param source_scheme: **(EXPERIMENTAL)** *(Optional)* Cookie source scheme type.
    :param source_port: **(EXPERIMENTAL)** *(Optional)* Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future.
    :param partition_key: **(EXPERIMENTAL)** *(Optional)* Cookie partition key. The site of the top-level URL the browser was visiting at the start of the request to the endpoint that set the cookie. If not set, the cookie will be set as not partitioned.
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    '''
    session = get_session_context('network.set_cookie')
    return await session.execute(cdp.network.set_cookie(name, value, url, domain, path, secure, http_only, same_site, expires, priority, same_party, source_scheme, source_port, partition_key))


async def set_cookies(
        cookies: typing.List[CookieParam]
    ) -> None:
    '''
    Sets given cookies.

    :param cookies: Cookies to be set.
    '''
    session = get_session_context('network.set_cookies')
    return await session.execute(cdp.network.set_cookies(cookies))


async def set_extra_http_headers(
        headers: Headers
    ) -> None:
    '''
    Specifies whether to always send extra HTTP headers with the requests from this page.

    :param headers: Map with extra HTTP headers.
    '''
    session = get_session_context('network.set_extra_http_headers')
    return await session.execute(cdp.network.set_extra_http_headers(headers))


async def set_request_interception(
        patterns: typing.List[RequestPattern]
    ) -> None:
    '''
Sets the requests to intercept that match the provided patterns and optionally resource types.
Deprecated, please use Fetch.enable instead.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param patterns: Requests matching any of these patterns will be forwarded and wait for the corresponding continueInterceptedRequest call.

.. deprecated:: 1.3
'''
    session = get_session_context('network.set_request_interception')
    return await session.execute(cdp.network.set_request_interception(patterns))


async def set_user_agent_override(
        user_agent: str,
        accept_language: typing.Optional[str] = None,
        platform: typing.Optional[str] = None,
        user_agent_metadata: typing.Optional[cdp.emulation.UserAgentMetadata] = None
    ) -> None:
    '''
    Allows overriding user agent with the given string.

    :param user_agent: User agent to use.
    :param accept_language: *(Optional)* Browser langugage to emulate.
    :param platform: *(Optional)* The platform navigator.platform should return.
    :param user_agent_metadata: **(EXPERIMENTAL)** *(Optional)* To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
    '''
    session = get_session_context('network.set_user_agent_override')
    return await session.execute(cdp.network.set_user_agent_override(user_agent, accept_language, platform, user_agent_metadata))


async def take_response_body_for_interception_as_stream(
        interception_id: InterceptionId
    ) -> cdp.io.StreamHandle:
    '''
    Returns a handle to the stream representing the response body. Note that after this command,
    the intercepted request can't be continued as is -- you either need to cancel it or to provide
    the response body. The stream only supports sequential read, IO.read will fail if the position
    is specified.

    **EXPERIMENTAL**

    :param interception_id:
    :returns: 
    '''
    session = get_session_context('network.take_response_body_for_interception_as_stream')
    return await session.execute(cdp.network.take_response_body_for_interception_as_stream(interception_id))
