# DO NOT EDIT THIS FILE!
#
# This code is generated off of PyCDP modules. If you need to make
# changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
import typing

from ..context import get_connection_context, get_session_context

import cdp.memory
from cdp.memory import (
    Module,
    PressureLevel,
    SamplingProfile,
    SamplingProfileNode
)


async def forcibly_purge_java_script_memory() -> None:
    r'''
    Simulate OomIntervention by purging V8 memory.
    '''
    session = get_session_context('memory.forcibly_purge_java_script_memory')
    return await session.execute(cdp.memory.forcibly_purge_java_script_memory())


async def get_all_time_sampling_profile() -> SamplingProfile:
    r'''
    Retrieve native memory allocations profile
    collected since renderer process startup.

    :returns: 
    '''
    session = get_session_context('memory.get_all_time_sampling_profile')
    return await session.execute(cdp.memory.get_all_time_sampling_profile())


async def get_browser_sampling_profile() -> SamplingProfile:
    r'''
    Retrieve native memory allocations profile
    collected since browser process startup.

    :returns: 
    '''
    session = get_session_context('memory.get_browser_sampling_profile')
    return await session.execute(cdp.memory.get_browser_sampling_profile())


async def get_dom_counters() -> typing.Tuple[int, int, int]:
    r'''


    :returns: A tuple with the following items:

        0. **documents** - 
        1. **nodes** - 
        2. **jsEventListeners** - 
    '''
    session = get_session_context('memory.get_dom_counters')
    return await session.execute(cdp.memory.get_dom_counters())


async def get_sampling_profile() -> SamplingProfile:
    r'''
    Retrieve native memory allocations profile collected since last
    ``startSampling`` call.

    :returns: 
    '''
    session = get_session_context('memory.get_sampling_profile')
    return await session.execute(cdp.memory.get_sampling_profile())


async def prepare_for_leak_detection() -> None:
    session = get_session_context('memory.prepare_for_leak_detection')
    return await session.execute(cdp.memory.prepare_for_leak_detection())


async def set_pressure_notifications_suppressed(
        suppressed: bool
    ) -> None:
    r'''
    Enable/disable suppressing memory pressure notifications in all processes.

    :param suppressed: If true, memory pressure notifications will be suppressed.
    '''
    session = get_session_context('memory.set_pressure_notifications_suppressed')
    return await session.execute(cdp.memory.set_pressure_notifications_suppressed(suppressed))


async def simulate_pressure_notification(
        level: PressureLevel
    ) -> None:
    r'''
    Simulate a memory pressure notification in all processes.

    :param level: Memory pressure level of the notification.
    '''
    session = get_session_context('memory.simulate_pressure_notification')
    return await session.execute(cdp.memory.simulate_pressure_notification(level))


async def start_sampling(
        sampling_interval: typing.Optional[int] = None,
        suppress_randomness: typing.Optional[bool] = None
    ) -> None:
    r'''
    Start collecting native memory profile.

    :param sampling_interval: *(Optional)* Average number of bytes between samples.
    :param suppress_randomness: *(Optional)* Do not randomize intervals between samples.
    '''
    session = get_session_context('memory.start_sampling')
    return await session.execute(cdp.memory.start_sampling(sampling_interval, suppress_randomness))


async def stop_sampling() -> None:
    r'''
    Stop collecting native memory profile.
    '''
    session = get_session_context('memory.stop_sampling')
    return await session.execute(cdp.memory.stop_sampling())
