# DO NOT EDIT THIS FILE!
#
# This code is generated off of PyCDP modules. If you need to make
# changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
import typing

from ..context import get_connection_context, get_session_context

import cdp.heap_profiler
from cdp.heap_profiler import (
    AddHeapSnapshotChunk,
    HeapSnapshotObjectId,
    HeapStatsUpdate,
    LastSeenObjectId,
    ReportHeapSnapshotProgress,
    ResetProfiles,
    SamplingHeapProfile,
    SamplingHeapProfileNode,
    SamplingHeapProfileSample
)


async def add_inspected_heap_object(
        heap_object_id: HeapSnapshotObjectId
    ) -> None:
    '''
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    :param heap_object_id: Heap snapshot object id to be accessible by means of $x command line API.
    '''
    session = get_session_context('heap_profiler.add_inspected_heap_object')
    return await session.execute(cdp.heap_profiler.add_inspected_heap_object(heap_object_id))


async def collect_garbage() -> None:
    session = get_session_context('heap_profiler.collect_garbage')
    return await session.execute(cdp.heap_profiler.collect_garbage())


async def disable() -> None:
    session = get_session_context('heap_profiler.disable')
    return await session.execute(cdp.heap_profiler.disable())


async def enable() -> None:
    session = get_session_context('heap_profiler.enable')
    return await session.execute(cdp.heap_profiler.enable())


async def get_heap_object_id(
        object_id: cdp.runtime.RemoteObjectId
    ) -> HeapSnapshotObjectId:
    '''
    :param object_id: Identifier of the object to get heap object id for.
    :returns: Id of the heap snapshot object corresponding to the passed remote object id.
    '''
    session = get_session_context('heap_profiler.get_heap_object_id')
    return await session.execute(cdp.heap_profiler.get_heap_object_id(object_id))


async def get_object_by_heap_object_id(
        object_id: HeapSnapshotObjectId,
        object_group: typing.Optional[str] = None
    ) -> cdp.runtime.RemoteObject:
    '''
    :param object_id:
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :returns: Evaluation result.
    '''
    session = get_session_context('heap_profiler.get_object_by_heap_object_id')
    return await session.execute(cdp.heap_profiler.get_object_by_heap_object_id(object_id, object_group))


async def get_sampling_profile() -> SamplingHeapProfile:
    '''


    :returns: Return the sampling profile being collected.
    '''
    session = get_session_context('heap_profiler.get_sampling_profile')
    return await session.execute(cdp.heap_profiler.get_sampling_profile())


async def start_sampling(
        sampling_interval: typing.Optional[float] = None
    ) -> None:
    '''
    :param sampling_interval: *(Optional)* Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
    '''
    session = get_session_context('heap_profiler.start_sampling')
    return await session.execute(cdp.heap_profiler.start_sampling(sampling_interval))


async def start_tracking_heap_objects(
        track_allocations: typing.Optional[bool] = None
    ) -> None:
    '''
    :param track_allocations: *(Optional)*
    '''
    session = get_session_context('heap_profiler.start_tracking_heap_objects')
    return await session.execute(cdp.heap_profiler.start_tracking_heap_objects(track_allocations))


async def stop_sampling() -> SamplingHeapProfile:
    '''


    :returns: Recorded sampling heap profile.
    '''
    session = get_session_context('heap_profiler.stop_sampling')
    return await session.execute(cdp.heap_profiler.stop_sampling())


async def stop_tracking_heap_objects(
        report_progress: typing.Optional[bool] = None,
        treat_global_objects_as_roots: typing.Optional[bool] = None,
        capture_numeric_value: typing.Optional[bool] = None
    ) -> None:
    '''
    :param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
    :param treat_global_objects_as_roots: *(Optional)*
    :param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot
    '''
    session = get_session_context('heap_profiler.stop_tracking_heap_objects')
    return await session.execute(cdp.heap_profiler.stop_tracking_heap_objects(report_progress, treat_global_objects_as_roots, capture_numeric_value))


async def take_heap_snapshot(
        report_progress: typing.Optional[bool] = None,
        treat_global_objects_as_roots: typing.Optional[bool] = None,
        capture_numeric_value: typing.Optional[bool] = None
    ) -> None:
    '''
    :param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
    :param treat_global_objects_as_roots: *(Optional)* If true, a raw snapshot without artificial roots will be generated
    :param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot
    '''
    session = get_session_context('heap_profiler.take_heap_snapshot')
    return await session.execute(cdp.heap_profiler.take_heap_snapshot(report_progress, treat_global_objects_as_roots, capture_numeric_value))
