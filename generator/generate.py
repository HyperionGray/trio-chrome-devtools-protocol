from __future__ import annotations
import inspect
import pathlib
from textwrap import indent as tw_indent
import types
import typing

import cdp


try:
    ForwardRef = typing.ForwardRef # type: ignore
except AttributeError:
    ForwardRef = typing._ForwardRef # type: ignore


cdp_modules = None


def indent(text: str, count: int):
    ''' Indent text with the specified number of spaces. '''
    return tw_indent(text, ' '  * count)


def main():
    ''' Main entry point. '''
    root = pathlib.Path(__file__).resolve().parent.parent / 'trio_cdp' / 'generated'
    clean(root)
    ignored = lambda name: name.startswith('_') or name in ('cdp', 'util')
    global cdp_modules
    cdp_modules = {n:m for n,m in inspect.getmembers(cdp) if not ignored(n)}
    for name, module in cdp_modules.items():
        generate_module(root, name, module)
    init = root / '__init__.py'
    with init.open('w') as file:
        file.write('# DO NOT EDIT THIS FILE!\n#\n')
        file.write('# This code is generated off of PyCDP modules. If you need to make\n')
        file.write('# changes, edit the generator and regenerate all of the modules.\n\n')
        for module in cdp_modules:
            file.write(f'from . import {module}\n')


def clean(root: pathlib.Path):
    ''' Remove files from directory. '''
    for path in root.iterdir():
        if path.is_file():
            path.unlink()


def generate_module(root: pathlib.Path, module_name: str, 
        module: types.ModuleType):
    ''' Generate code for a module. '''
    print('* Generating module:', module_name)
    module_path = root / f'{module_name}.py'
    commands = list()
    classes = list()
    for name, obj in inspect.getmembers(module):
        if name.startswith('_') or name in ('dataclass', 'deprecated', 'event_class'):
            continue
        if inspect.isfunction(obj):
            commands.append(generate_command(module, module_name, obj))
        elif inspect.isclass(obj):
            classes.append(name)

    with module_path.open('w') as file:
        file.write('# DO NOT EDIT THIS FILE!\n#\n')
        file.write('# This code is generated off of PyCDP modules. If you need to make\n')
        file.write('# changes, edit the generator and regenerate all of the modules.\n\n')
        file.write('from __future__ import annotations\n')
        file.write('import typing\n\n')
        file.write('from ..context import get_connection_context, get_session_context\n\n')
        file.write(f'import cdp.{module_name}\n')
        if classes:
            file.write(f'from cdp.{module_name} import (\n')
            file.write(indent(',\n'.join(classes), 4))
            file.write('\n)\n\n\n')
        else:
            file.write('\n')
        file.write('\n\n'.join(commands))


def generate_command(module: types.ModuleType, module_name: str, 
        fn: types.FunctionType):
    ''' Generate code for one command, i.e. one PyCDP wrapper function. '''
    fn_name = fn.__name__
    print(f'  - {fn_name}()')
    sig = inspect.signature(fn)
    type_hints = typing.get_type_hints(fn, globalns=vars(module), localns=None)

    # Generate the argument list.
    args = list()
    call_args = list()
    for param in sig.parameters.values():
        ann = format_annotation(module, type_hints[param.name])
        if param.default != inspect.Parameter.empty:
            default_str = f' = {param.default}'
        else:
            default_str = ''
        args.append(f'{param.name}: {ann}{default_str}')
        call_args.append(param.name)

    if len(args) == 0:
        arg_str = ', '.join(args)
    else:
        arg_str = indent('\n' + ',\n'.join(args), 8) + '\n    '

    call_arg_str = ', '.join(call_args)

    # Copy docstring.
    if fn.__doc__:
        doc = "    r'''" + fn.__doc__ + "'''\n"
    else:
        doc = ''

    # The original function returns a generator. We want to grab the return type of the
    # generator and set that as the return type of this wrapper function.        
    return_type = format_annotation(module, type_hints['return'].__args__[2])

    # Format the function and return it as a string.
    ctx_name, ctx_fn = which_context(module_name, fn_name)
    body = f"{ctx_name} = {ctx_fn}('{module_name}.{fn_name}')\n"
    body += f"return await {ctx_name}.execute(cdp.{module_name}.{fn_name}({call_arg_str}))"
    body = indent(body, 4)
    return f'async def {fn_name}({arg_str}) -> {return_type}:\n{doc}{body}\n'


def format_annotation(current_module: types.ModuleType, ann: typing.Any):
    '''
    Given a type annotation, return a stringified version.

    This is ugly since it seems there's not much official tooling for manipulating
    types. Many of the types are all of the same class ``typing._GenericAlias``, and we
    have to access private members to figure out what the specific annotation actually
    is.
    '''
    if ann is type(None):
        ann_str = 'None'
    elif isinstance(ann, type):
        if ann.__module__ not in (current_module.__name__, 'builtins'):
            ann_str = f'{ann.__module__}.{ann.__name__}'
        else:
            ann_str = ann.__name__
    elif ann._name == 'Any':
        ann_str = 'typing.Any'
    elif ann._name == 'List':
        nested_ann = format_annotation(current_module, ann.__args__[0])
        ann_str = f'typing.List[{nested_ann}]'
    elif ann._name == 'Tuple':
        nested_anns = ', '.join(format_annotation(current_module, a) for a in ann.__args__)
        ann_str = f'typing.Tuple[{nested_anns}]'
    elif ann._name is None and len(ann.__args__) > 1:
        # For some reason union annotations don't have a name?
        # If the union has two members and one of them is NoneType, then it's really
        # a typing.Optional.
        if len(ann.__args__) == 2 and any(a is type(None) for a in ann.__args__):
            opt_type = [a for a in ann.__args__ if a is not type(None)][0]
            nested_ann = format_annotation(current_module, opt_type)
            ann_str = f'typing.Optional[{nested_ann}]'
        else:
            nested_anns = ', '.join(format_annotation(current_module, a) for a in ann.__args__)
            ann_str = f'typing.Union[{nested_anns}]'
    else:
        raise Exception(f'Cannot format annotation: {repr(ann)}')
    return ann_str


def which_context(module: str, name: str):
    '''
    Returns the information for which context to use when executing a particular
    function.

    Returns a tuple of the variable name for the context and the function name that
    retrieves the context.
    '''
    if module == 'target':
        context = 'connection', 'get_connection_context'
    else:
        context = 'session', 'get_session_context'
    return context


if __name__ == '__main__':
    main()
